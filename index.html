<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>PKM Lite - Leitor Markdown v1.6.1</title>
    <meta name="theme-color" content="#1e1e1e">
    <link rel="manifest" href="manifest.json">
    
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=JetBrains+Mono:wght@400;500&family=Merriweather:wght@300;400;700&display=swap" rel="stylesheet">

    <style>
        /* [Mantive o CSS id√™ntico ao v1.5 para economizar espa√ßo, insira o CSS da resposta anterior aqui] */
        :root { --bg-color: #ffffff; --text-color: #2c3e50; --sidebar-bg: #f8f9fa; --primary: #007bff; --accent: #007bff; --border-color: #e9ecef; --font-main: 'Inter', sans-serif; --font-code: 'JetBrains Mono', monospace; --max-width: 720px; --font-size: 18px; --line-height: 1.8; }
        [data-theme="dark"] { --bg-color: #1a1a1a; --text-color: #e0e0e0; --sidebar-bg: #252525; --border-color: #444; --accent: #4dabf7; }
        [data-theme="sepia"] { --bg-color: #f4ecd8; --text-color: #5b4636; --sidebar-bg: #e4dcc8; --border-color: #d3c4a9; --accent: #d35400; }
        body { margin: 0; font-family: var(--font-main); background-color: var(--bg-color); color: var(--text-color); transition: background 0.3s; overflow-x: hidden; padding-bottom: 90px; }
        #app-container { display: grid; grid-template-columns: 0 1fr 0; min-height: 100vh; transition: 0.3s; }
        #app-container.show-sidebar { grid-template-columns: 300px 1fr 0; }
        #app-container.show-toc { grid-template-columns: 0 1fr 250px; }
        #app-container.show-all { grid-template-columns: 300px 1fr 250px; }
        aside#sidebar { background: var(--sidebar-bg); border-right: 1px solid var(--border-color); overflow-y: auto; height: 100vh; position: sticky; top: 0; padding: 1rem; display: none; }
        #debug-console { position: fixed; right: 0; top: 50px; width: 300px; height: 300px; background: rgba(0,0,0,0.9); color: #0f0; font-family: monospace; font-size: 10px; padding: 10px; overflow-y: auto; z-index: 99998; border-left: 2px solid #0f0; display: none; }
        #debug-console.visible { display: block; }
        #debug-console .log-entry { margin-bottom: 5px; border-bottom: 1px solid #333; padding-bottom: 3px; }
        .show-sidebar aside#sidebar { display: block; }
        .lib-item { padding: 10px; border-radius: 6px; margin-bottom: 5px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
        .lib-item:hover { background: rgba(0,0,0,0.05); }
        .lib-item.active { background: rgba(var(--primary), 0.1); border-left: 3px solid var(--accent); }
        main { overflow: visible; }
        #content { margin-top: 60px; padding: 40px 20px 20px 20px; max-width: var(--max-width); margin: 0 auto; line-height: var(--line-height); font-size: var(--font-size); }
        aside#toc { background: var(--bg-color); border-left: 1px solid var(--border-color); height: 100vh; overflow-y: auto; position: sticky; top: 0; padding: 80px 15px 20px 15px; font-size: 0.85rem; display: none; }
        .show-toc aside#toc, .show-all aside#toc { display: block; }
        #toc ul { list-style: none; padding: 0; } #toc li { margin-bottom: 8px; } #toc a { text-decoration: none; color: var(--text-color); opacity: 0.7; display: block; transition: 0.2s; border-left: 2px solid transparent; padding-left: 8px;} #toc a:hover, #toc a.active { opacity: 1; color: var(--accent); border-left-color: var(--accent); font-weight: 600; } #toc .toc-h3 { margin-left: 15px; font-size: 0.9em; }
        header { height: 50px; position: fixed; top: 0; left: 0; right: 0; background: rgba(var(--bg-color), 0.95); backdrop-filter: blur(5px); border-bottom: 1px solid var(--border-color); z-index: 1000; display: flex; align-items: center; justify-content: space-between; padding: 0 15px; }
        pre { background: #282c34; border-radius: 8px; margin: 1.5rem 0; padding: 15px; overflow-x: auto; }
        code { font-family: var(--font-code); }
        #media-bar { position: fixed !important; bottom: 0 !important; left: 0 !important; right: 0 !important; height: 75px; background: #2c3e50 !important; border-top: 3px solid #007bff !important; display: flex !important; align-items: center; justify-content: space-between; padding: 0 20px; z-index: 99999 !important; transform: translateY(0) !important; transition: none; box-shadow: 0 -2px 10px rgba(0,0,0,0.5); pointer-events: auto !important; visibility: visible !important; color: white !important; }
        #media-bar.visible { transform: translateY(0) !important; }
        #media-bar * { color: white !important; }
        .player-controls { display: flex; gap: 20px; align-items: center; font-size: 1.5rem; }
        .btn-icon { background:none; border:none; font-size: 1.2rem; cursor: pointer; color: var(--text-color); padding: 5px; }
        /* Indicador de microfone */
        #mic-indicator { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 200px; height: 200px; background: rgba(0, 123, 255, 0.9); border-radius: 50%; display: none; align-items: center; justify-content: center; z-index: 100000; animation: pulse 1.5s ease-in-out infinite; box-shadow: 0 0 30px rgba(0, 123, 255, 0.5); }
        #mic-indicator.active { display: flex; }
        #mic-indicator::after { content: 'üé§'; font-size: 80px; }
        @keyframes pulse { 0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.9; } 50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; } }
        @media (max-width: 768px) { #app-container.show-toc { grid-template-columns: 0 1fr 0; } aside#toc { display: none; } }
        /* Heading em reprodu√ß√£o */
#content .tts-playing {
  outline: 2px solid var(--accent);
  outline-offset: 6px;
  border-radius: 6px;
}

/* opcional: TOC em reprodu√ß√£o (al√©m do active do scroll spy) */
#toc a.tts-playing {
  opacity: 1;
  color: var(--accent);
  font-weight: 700;
}

    </style>
</head>
<body>

    <header>
        <div style="display:flex; gap:10px">
            <button class="btn-icon" onclick="UI.toggleSidebar()">üìö</button>
            <span id="doc-title" style="font-weight:600; font-size:0.9rem; margin-top:5px; white-space:nowrap; overflow:hidden; max-width:200px">Minha Biblioteca</span>
        </div>
        <div style="display:flex; gap:10px">
             <button class="btn-icon" title="Ouvir" onclick="TTS.togglePanel()">üéß</button>
             <button class="btn-icon" id="btn-handsfree" title="Hands-free" onclick="Config.toggleHandsFree()">üéôÔ∏è</button>
             <button class="btn-icon" title="Configura√ß√µes" onclick="UI.toggleSettings()">‚öôÔ∏è</button>
             <button class="btn-icon" title="Sum√°rio" onclick="UI.toggleTOC()">üìë</button>
             <button class="btn-icon" title="Debug Console" onclick="UI.toggleDebug()">üêõ</button>
        </div>
    </header>

    <div id="app-container" class="show-sidebar">
        <aside id="sidebar">
            <div id="panel-library">
                <button onclick="Library.importFile()" style="top: 50px; position: relative; width:100%; padding:10px; background:var(--accent); color:white; border:none; border-radius:5px; margin-bottom:15px; font-weight:bold">+ Importar</button>
                <div id="file-list" style="top: 100px"></div>
            </div>
            <div id="panel-settings" style="display:none">
                 <h3>Apar√™ncia</h3>
                 <button onclick="Config.setTheme('light'); UI.toggleSettings()">‚òÄÔ∏è Claro</button>
                 <button onclick="Config.setTheme('dark'); UI.toggleSettings()">üåô Escuro</button>
                 <button onclick="Config.setTheme('sepia'); UI.toggleSettings()">üìñ S√©pia</button>
                 <br><br>
                 <button onclick="UI.toggleSettings()">Voltar</button>
            </div>
        </aside>

        <main>
            <div id="content">
                <div style="text-align:center; margin-top:100px; color:#888">
                    <h2>MD Reader v1.6.1</h2>
                    <p>Carregue um arquivo para come√ßar.</p>
                </div>
            </div>
        </main>

        <aside id="toc">
            <h4 style="margin-top:0">Neste documento</h4>
            <div id="toc-list"></div>
        </aside>
    </div>

    <div id="debug-console"></div>

    <div id="mic-indicator"></div>

    <div id="media-bar">
        <div style="width:30%">
            <div id="tts-chapter" style="font-weight:bold; font-size:0.9rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">--</div>
            <div id="tts-status" style="font-size:0.75rem; opacity:0.7">Parado</div>
        </div>
        <div class="player-controls">
            <span onclick="TTS.prev()" style="cursor:pointer" title="Cap√≠tulo Anterior">‚èÆ</span>
            <span onclick="TTS.toggle()" id="tts-play-btn" style="cursor:pointer; width:40px; text-align:center">‚ñ∂</span>
            <span onclick="TTS.next()" style="cursor:pointer" title="Pr√≥ximo Cap√≠tulo">‚è≠</span>
        </div>
        <div style="width:30%; text-align:right">
            <select id="tts-speed" onchange="TTS.setSpeed()" style="border:none; bg:transparent">
                <option value="1">1.0x</option>
                <option value="1.5">1.5x</option>
                <option value="2">2.0x</option>
            </select>
        </div>
    </div>

    <script>
        // --- DEBUG CONSOLE ---
        const DebugConsole = {
            maxLogs: 100,
            init() {
                const original = console.log;
                const originalWarn = console.warn;
                const originalError = console.error;

                console.log = (...args) => {
                    original.apply(console, args);
                    this.addLog('LOG', args.join(' '));
                };

                console.warn = (...args) => {
                    originalWarn.apply(console, args);
                    this.addLog('WARN', args.join(' '), '#ff0');
                };

                console.error = (...args) => {
                    originalError.apply(console, args);
                    this.addLog('ERROR', args.join(' '), '#f00');
                };

                this.addLog('INFO', 'Debug Console iniciado - v1.6.1', '#0ff');
            },

            addLog(type, message, color = '#0f0') {
                const consoleEl = document.getElementById('debug-console');
                if (!consoleEl) return;

                const entry = document.createElement('div');
                entry.className = 'log-entry';
                entry.style.color = color;

                const time = new Date().toLocaleTimeString();
                entry.innerHTML = `<strong>[${time}] ${type}:</strong> ${message}`;

                consoleEl.appendChild(entry);

                // Limita quantidade de logs
                while (consoleEl.children.length > this.maxLogs) {
                    consoleEl.removeChild(consoleEl.firstChild);
                }

                // Auto-scroll para o final
                consoleEl.scrollTop = consoleEl.scrollHeight;
            }
        };

        // --- 1. BANCO DE DADOS (Corre√ß√£o: Promise Nativa) ---
        const DB = {
            dbName: 'MDLibraryDB',
            version: 1,
            init: () => new Promise((resolve, reject) => {
                const req = indexedDB.open(DB.dbName, DB.version);
                req.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('files')) {
                        db.createObjectStore('files', { keyPath: 'id' });
                    }
                };
                req.onsuccess = (e) => resolve(e.target.result);
                req.onerror = (e) => reject(e);
            }),
            saveFile: async (fileData) => {
                const db = await DB.init();
                return new Promise((resolve, reject) => {
                    const tx = db.transaction('files', 'readwrite');
                    const store = tx.objectStore('files');
                    const req = store.put(fileData);
                    
                    // A transa√ß√£o completa √© a garantia real
                    tx.oncomplete = () => resolve(req.result);
                    tx.onerror = () => reject(tx.error);
                });
            },
            getAll: async () => {
                const db = await DB.init();
                return new Promise((resolve) => {
                    const tx = db.transaction('files', 'readonly');
                    tx.objectStore('files').getAll().onsuccess = (e) => resolve(e.target.result);
                });
            },
            get: async (id) => {
                const db = await DB.init();
                return new Promise((resolve) => {
                    const tx = db.transaction('files', 'readonly');
                    tx.objectStore('files').get(id).onsuccess = (e) => resolve(e.target.result);
                });
            }
        };

        // --- 2. CONFIGURA√á√ÉO ---
const Config = {
  settings: JSON.parse(localStorage.getItem('md_settings')) || {
    theme: 'light',
    handsFree: true,
    askOnTable: true,
    askOnList: true,
    readCode: false
  },

  apply: () => {
    document.documentElement.setAttribute('data-theme', Config.settings.theme);
    Voice.enabled = !!Config.settings.handsFree;
    Config.refreshHandsFreeButton();
  },

  save: () => localStorage.setItem('md_settings', JSON.stringify(Config.settings)),

  setTheme: (t) => { Config.settings.theme = t; Config.save(); Config.apply(); },

  toggleHandsFree: () => {
    Config.settings.handsFree = !Config.settings.handsFree;
    Config.save(); Config.apply();
  },

  refreshHandsFreeButton: () => {
    const btn = document.getElementById('btn-handsfree');
    if (!btn) return;
    btn.style.opacity = Config.settings.handsFree ? '1' : '0.35';
    btn.title = Config.settings.handsFree ? 'Hands-free: ON' : 'Hands-free: OFF';
  }
};


        // --- 3. RENDERIZADOR & TOC INTELIGENTE ---
        const Renderer = {
            render: (md) => {
                // 1. Parse b√°sico
                marked.setOptions({
                    highlight: (code, lang) => hljs.highlight(code, {
                         language: hljs.getLanguage(lang) ? lang : 'plaintext' }).value
                });
                let html = DOMPurify.sanitize(marked.parse(md));

                // 2. Injeta no DOM para processamento p√≥s-render
                const contentDiv = document.getElementById('content');
                contentDiv.innerHTML = html;

                // 3. Processamento de IDs e TOC (Non-destructive)
                Renderer.processStructure(contentDiv);

                // 4. Extras
                renderMathInElement(contentDiv, { delimiters: [{left: "$$", right: "$$", display: true}, {left: "$", right: "$", display: false}] });
                try { mermaid.run({ nodes: document.querySelectorAll('.mermaid') }); } catch(e){}

                // 5. Build TTS Playlist
                console.log('Iniciando buildPlaylistFromDOM...');
                TTS.buildPlaylistFromDOM();
                console.log('Playlist constru√≠da. Total de cap√≠tulos:', TTS.playlist.length);

                // 6. Verifica posicionamento do media-bar (Android debug)
                setTimeout(() => {
                    const bar = document.getElementById('media-bar');
                    if (bar) {
                        const rect = bar.getBoundingClientRect();
                        const computed = getComputedStyle(bar);
                        console.log('[Media-bar Debug] position:', computed.position);
                        console.log('[Media-bar Debug] bottom:', computed.bottom);
                        console.log('[Media-bar Debug] z-index:', computed.zIndex);
                        console.log('[Media-bar Debug] rect.top:', rect.top);
                        console.log('[Media-bar Debug] rect.bottom:', rect.bottom);
                        console.log('[Media-bar Debug] window.innerHeight:', window.innerHeight);
                        console.log('[Media-bar Debug] Est√° vis√≠vel na viewport?', rect.top < window.innerHeight && rect.bottom > 0);
                    }
                }, 200);

                // 7. MD renderizado
                console.log('MD renderizado completamente.');
            },

            processStructure: (root) => {
                const headers = root.querySelectorAll('h1, h2, h3');
                const tocList = document.getElementById('toc-list');
                let tocHtml = '<ul>';
                const usedIds = new Set();

                headers.forEach((h) => {
                    // Slugify: converte "Meu T√≠tulo" -> "meu-titulo"
                    let slug = h.innerText.toLowerCase().trim()
                        .replace(/[^\w\s-]/g, '')
                        .replace(/[\s_-]+/g, '-')
                        .replace(/^-+|-+$/g, '');
                    
                    if (!slug) slug = 'secao';

                    // Respeita ID existente, sen√£o gera novo com dedupe
                    if (!h.id) {
                        let uniqueSlug = slug;
                        let counter = 1;
                        while (usedIds.has(uniqueSlug)) {
                            uniqueSlug = `${slug}-${counter++}`;
                        }
                        h.id = uniqueSlug;
                    }
                    usedIds.add(h.id);

                    // Cria link do TOC
                    const cls = h.tagName === 'H3' ? 'class="toc-h3"' : '';
                    tocHtml += `<li ${cls}><a href="#${h.id}">${h.innerText}</a></li>`;
                });
                
                tocHtml += '</ul>';
                tocList.innerHTML = tocHtml;

                // Intersection Observer para Scroll Spy
                Renderer.initScrollSpy(headers);
            },

            initScrollSpy: (headers) => {
                if(Renderer.observer) Renderer.observer.disconnect();
                Renderer.observer = new IntersectionObserver(entries => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            document.querySelectorAll('#toc a').forEach(a => a.classList.remove('active'));
                            const id = entry.target.id;
                            const link = document.querySelector(`#toc a[href="#${id}"]`);
                            if(link) link.classList.add('active');
                            
                            // Sincroniza o cap√≠tulo do TTS visualmente se n√£o estiver tocando
                            if (!TTS.isPlaying) {
                                const index = TTS.playlist.findIndex(track => track.id === id);
                                if(index >= 0) TTS.updateDisplay(index);
                            }
                        }
                    });
                }, { rootMargin: '-10% 0px -80% 0px' });
                headers.forEach(h => Renderer.observer.observe(h));
            }
        };

        // --- 4. TTS PODCAST ENGINE (Cap√≠tulos) ---
        const TTS = {
  synth: window.speechSynthesis,
  userIsScrolling: false,
lastAutoScrollAt: 0,
  voicesLoaded: false,
  initPromise: null,
  wakeLock: null,

  playlist: [],     // [{ id,title,tokens:[...] }]
  currentChapter: 0,
  currentToken: 0,

  isPlaying: false,
  utterance: null,
  stopFlag: false,

  // Wake Lock para evitar que o device durma (Android)
  async acquireWakeLock() {
    if ('wakeLock' in navigator) {
      try {
        this.wakeLock = await navigator.wakeLock.request('screen');
        console.log('Wake Lock adquirido');

        this.wakeLock.addEventListener('release', () => {
          console.log('Wake Lock liberado');
        });
      } catch (e) {
        console.warn('N√£o foi poss√≠vel adquirir Wake Lock:', e);
      }
    }
  },

  releaseWakeLock() {
    if (this.wakeLock) {
      this.wakeLock.release();
      this.wakeLock = null;
    }
  },

  // Inicializa vozes (Android Chrome precisa disso)
  initVoices() {
    if (this.initPromise) return this.initPromise;

    this.initPromise = new Promise((resolve) => {
      const voices = this.synth.getVoices();
      if (voices.length > 0) {
        this.voicesLoaded = true;
        resolve();
        return;
      }

      // Android Chrome precisa do evento
      if ('onvoiceschanged' in this.synth) {
        this.synth.onvoiceschanged = () => {
          this.voicesLoaded = true;
          resolve();
        };
      } else {
        // Fallback
        setTimeout(() => {
          this.voicesLoaded = true;
          resolve();
        }, 100);
      }
    });

    return this.initPromise;
  },

  // ===== Util: texto "humano" =====
  cleanText(s) {
    return (s || '')
      .replace(/\s+/g, ' ')
      .replace(/\u00A0/g, ' ')
      .trim();
  },

  ensureEndPunct(s) {
    if (!s) return '';
    const last = s.slice(-1);
    if ('.!?‚Ä¶'.includes(last)) return s;
    // fim de par√°grafo -> d√° pausa natural
    return s + '.';
  },

  highlightChapterById(id) {
  // limpa destaque anterior
  document.querySelectorAll('#content .tts-playing').forEach(el => el.classList.remove('tts-playing'));
  document.querySelectorAll('#toc a.tts-playing').forEach(el => el.classList.remove('tts-playing'));

  const h = document.getElementById(id);
  if (h) h.classList.add('tts-playing');

  const tocLink = document.querySelector(`#toc a[href="#${CSS.escape(id)}"]`);
  if (tocLink) tocLink.classList.add('tts-playing');
},

scrollToChapterById(id) {
  const h = document.getElementById(id);
  if (!h) return;

  // evita brigar com o usu√°rio caso ele esteja rolando manualmente
  // (voc√™ pode remover esse guard se quiser for√ßar sempre)
  if (TTS.userIsScrolling) return;

  // header fixo de 50px + folga
  const y = h.getBoundingClientRect().top + window.scrollY - 70;

  window.scrollTo({
    top: Math.max(0, y),
    behavior: 'smooth'
  });
},


applySpeechDictionary(text) {
  let t = text || '';

  // 1) placeholders <objeto> -> objeto  (remove < >)
  t = t.replace(/<([^>]+)>/g, '$1');

  // 2) trocar ex: / ex.: -> exemplo:
  t = t.replace(/\bex\.\s*:/gi, 'exemplo:');
  t = t.replace(/\bex\s*:/gi, 'exemplo:');

  // 3) obs: -> observa√ß√£o:
  t = t.replace(/\bobs\s*:/gi, 'observa√ß√£o:');

  // 4) etc. -> etc√©tera (opcional)
  t = t.replace(/\betc\.\b/gi, 'etc√©tera');

  // 5) padr√µes comuns em c√≥digo
  t = t.replace(/_/g, ' ');          // calendario_core -> calendario core
  t = t.replace(/\.sql\b/gi, ' ponto s q l');
  t = t.replace(/\.py\b/gi, ' ponto p y');
  t = t.replace(/\.ipynb\b/gi, ' ponto i p i n b');

  return this.cleanText(t);
},



  // quebra texto grande em chunks (evita TTS engasgar e melhora pausas)
  chunkText(text, maxLen = 900) {
    const t = this.cleanText(text);
    if (t.length <= maxLen) return [t];

    // tenta dividir por frases
    const sentences = t.split(/(?<=[\.\!\?‚Ä¶])\s+/);
    const chunks = [];
    let cur = '';

    for (const s of sentences) {
      if (!s) continue;
      if ((cur + ' ' + s).trim().length > maxLen) {
        if (cur.trim()) chunks.push(cur.trim());
        cur = s;
      } else {
        cur = (cur ? cur + ' ' : '') + s;
      }
    }
    if (cur.trim()) chunks.push(cur.trim());
    return chunks;
  },

  // ===== DOM -> playlist tokenizada =====
  buildPlaylistFromDOM() {
    console.log('[TTS] buildPlaylistFromDOM iniciado');
    const root = document.getElementById('content');
    const children = Array.from(root.children);
    console.log('[TTS] Total de elementos no content:', children.length);

    this.playlist = [];
    let chapter = { id: 'intro', title: 'Introdu√ß√£o', tokens: [] };

    const pushChapter = () => {
      if (chapter.tokens.length) this.playlist.push(chapter);
    };

    const pushToken = (type, payload) => {
      chapter.tokens.push({ type, ...payload });
    };

    for (const el of children) {
      const tag = el.tagName;

      if (tag === 'H1' || tag === 'H2') {
        pushChapter();
        chapter = { id: el.id || 'secao', title: this.cleanText(el.innerText) || 'Se√ß√£o', tokens: [] };
  // üëá token para o TTS falar o t√≠tulo
  pushToken('heading', { text: chapter.title, id: chapter.id });

        continue;
      }

      if (tag === 'H3') {
  const t = this.cleanText(el.innerText);
  if (t) pushToken('subheading', { text: t, id: el.id || '' });
  continue;
}

      if (tag === 'P' || tag === 'BLOCKQUOTE') {
        const txt = this.ensureEndPunct(this.cleanText(el.innerText));
        if (txt) pushToken('text', { text: txt });
        continue;
      }

      if (tag === 'UL' || tag === 'OL') {
        const items = Array.from(el.querySelectorAll('li'))
          .map(li => this.ensureEndPunct(this.cleanText(li.innerText)))
          .filter(Boolean);

        if (items.length) pushToken('list', { items });
        continue;
      }

      if (tag === 'TABLE') {
        // guarda como estrutura; fala depois (com gate)
        const rows = Array.from(el.querySelectorAll('tr'))
          .map(tr => Array.from(tr.querySelectorAll('th,td')).map(td => this.cleanText(td.innerText)));
        if (rows.length) pushToken('table', { rows });
        continue;
      }

      if (tag === 'PRE') {
        if (Config.settings.readCode) {
          pushToken('text', { text: 'Trecho de c√≥digo. ' + this.ensureEndPunct(this.cleanText(el.innerText)) });
        } else {
          pushToken('text', { text: 'Trecho de c√≥digo ignorado.' });
        }
        continue;
      }

      // fallback: pega texto de outros blocos (ex: H3, HR, etc.)
      const fallback = this.cleanText(el.innerText);
      if (fallback) pushToken('text', { text: this.ensureEndPunct(fallback) });
    }

    pushChapter();

    console.log('[TTS] Playlist constru√≠da com', this.playlist.length, 'cap√≠tulos');
    this.playlist.forEach((ch, i) => {
      console.log(`[TTS] Cap ${i}: "${ch.title}" - ${ch.tokens.length} tokens`);
    });

    this.currentChapter = 0;
    this.currentToken = 0;

    // atualiza display
    this.updateDisplay();
  },

  // ===== Tabela -> fala ‚Äúhumana‚Äù =====
  tableToSpeech(rows) {
    if (!rows?.length) return 'Tabela vazia.';
    const header = rows[0] || [];
    const body = rows.slice(1);

    let out = `Tabela com ${body.length} linhas e ${header.length} colunas. `;
    if (header.length) out += `Cabe√ßalhos: ${header.join(', ')}. `;

    const limit = 20;
    body.slice(0, limit).forEach((r, i) => {
      out += `Linha ${i + 1}: ${r.join('; ')}. `;
    });
    if (body.length > limit) out += 'Restante omitido. ';
    return out;
  },

  // ===== Player token por token (pausas naturais) =====
  async playFromHere() {
    this.stopFlag = false;
    this.isPlaying = true;
    this.updateControls();

    console.log('[TTS] playFromHere iniciado');

    // Adquire Wake Lock para evitar que o device durma
    await this.acquireWakeLock();

    // Android Chrome workaround: periodicamente verifica se est√° travado
    const keepAliveInterval = setInterval(() => {
      if (!this.isPlaying) {
        clearInterval(keepAliveInterval);
        return;
      }

      // Se synth diz que est√° falando mas n√£o tem utterance, pode estar travado
      if (this.synth.speaking && !this.synth.pending && this.utterance) {
        // "Cutucar" o synth para garantir que est√° vivo
        // (Android Chrome bug conhecido)
        this.synth.pause();
        this.synth.resume();
      }
    }, 5000); // Verifica a cada 5 segundos

    while (!this.stopFlag) {
      const chap = this.playlist[this.currentChapter];
      if (!chap) {
        console.log('[TTS] Fim da playlist');
        break;
      }

      const token = chap.tokens[this.currentToken];
      if (!token) {
        // fim do cap√≠tulo -> pr√≥ximo
        console.log('[TTS] Fim do cap√≠tulo, avan√ßando...');
        this.currentChapter += 1;
        this.currentToken = 0;
        this.updateDisplay();
        continue;
      }

      console.log(`[TTS] Tocando token ${this.currentToken} do cap ${this.currentChapter}: tipo=${token.type}`);

      // CR√çTICO: Aguarda o token terminar COMPLETAMENTE antes de avan√ßar
      await this.playToken(token);

      console.log(`[TTS] Token ${this.currentToken} conclu√≠do`);

      // avan√ßa apenas DEPOIS que o token terminou
      this.currentToken += 1;
      this.updateDisplay();

      // micro-pausa entre tokens (d√° "respiro")
      await new Promise(r => setTimeout(r, 300));
    }

    // Limpa o keepAlive interval
    clearInterval(keepAliveInterval);

    // Libera Wake Lock
    this.releaseWakeLock();

    this.isPlaying = false;
    this.updateControls(true);
    console.log('[TTS] playFromHere finalizado');
  },

  async playToken(token) {
    if (this.stopFlag) return;



if (token.type === 'heading') {
  await this.speak(`Cap√≠tulo. ${this.ensureEndPunct(token.text)}`);
  await new Promise(r => setTimeout(r, 2000));
  return;
}


if (token.type === 'subheading') {
  await this.speak(`Se√ß√£o. ${this.ensureEndPunct(token.text)}`);
  await new Promise(r => setTimeout(r, 1200));
  return;
}

    if (token.type === 'text') {
      const chunks = this.chunkText(token.text);
      for (const c of chunks) {
        if (this.stopFlag) return;
        await this.speak(c);
      }
      return;
    }

    if (token.type === 'list') {
      const count = token.items.length;

      console.log(`[TTS] Lista encontrada com ${count} itens`);

      if (Config.settings.askOnList && Voice.enabled && count >= 6) {
        const ans = await Voice.askYesNo(`Encontrei uma lista com ${count} itens. Quer que eu leia a lista? Diga sim ou n√£o.`);
        console.log(`[TTS] Resposta do usu√°rio para lista:`, ans);
        if (ans === false) {
          await this.speak(`Lista ignorada.`);
          return;
        }
      }

      // l√™ listinha item por item (bem mais natural)
      await this.speak(`Lista com ${count} itens.`);

      for (let i = 0; i < token.items.length; i++) {
        if (this.stopFlag) {
          console.log('[TTS] stopFlag detectado durante leitura de lista');
          return;
        }
        console.log(`[TTS] Lendo item ${i + 1} de ${count}`);
        await this.speak(`Item ${i + 1}: ${token.items[i]}`);
      }

      console.log('[TTS] Lista conclu√≠da');
      return;
    }

    if (token.type === 'table') {
      if (Config.settings.askOnTable && Voice.enabled) {
        const ans = await Voice.askYesNo('Encontrei uma tabela. Quer que eu leia a tabela? Diga sim ou n√£o.');
        if (ans === false) {
          await this.speak('Tabela ignorada.');
          return;
        }
      }
      await this.speak(this.tableToSpeech(token.rows));
      return;
    }


},


async speak(text) {
  if (this.stopFlag) return;

  const rate = parseFloat(document.getElementById('tts-speed')?.value) || 1.0;
  const normalized = this.applySpeechDictionary(text);

  // Se tiver ":" (ex: "SQL: ..."), fala antes, pausa, depois o resto
  // (funciona bem para ‚ÄúComent√°rio:‚Äù ‚ÄúSQL:‚Äù etc.)
  const parts = normalized.split(':');

  if (parts.length > 1) {
    // fala "SQL:" (ou o que for antes do primeiro :)
    await this.speakOnce(parts[0].trim() + ':', rate);
    await new Promise(r => setTimeout(r, 1500));

    // fala o restante juntando os : extras com pausas menores
    for (let i = 1; i < parts.length; i++) {
      if (this.stopFlag) return;
      const chunk = parts[i].trim();
      if (!chunk) continue;

      await this.speakOnce(chunk, rate);

      // se tinha m√∫ltiplos ":", pausa curta entre segmentos
      if (i < parts.length - 1) await new Promise(r => setTimeout(r, 800));
    }
    return;
  }

  // sem ":" -> fala normal (mas chunked)
  const chunks = this.chunkText(normalized);
  for (const c of chunks) {
    if (this.stopFlag) return;
    await this.speakOnce(c, rate);
  }
},

async speakOnce(text, rate) {
  if (this.stopFlag) return;

  // Garante que vozes est√£o carregadas (cr√≠tico no Android)
  await this.initVoices();

  return new Promise((resolve) => {
    if (this.stopFlag) return resolve();

    const u = new SpeechSynthesisUtterance(text);
    u.rate = rate;

    // Android Chrome: eventos podem n√£o disparar, usa timeout como fallback
    let ended = false;
    const finish = () => {
      if (ended) return;
      ended = true;
      resolve();
    };

    // Timeout de seguran√ßa (texto.length * fator + margem)
    const estimatedDuration = (text.length / rate) * 60 + 2000;
    const safetyTimeout = setTimeout(finish, estimatedDuration);

    u.onend = () => {
      clearTimeout(safetyTimeout);
      finish();
    };

    u.onerror = (e) => {
      console.error('TTS error:', e.error, 'type:', e.type, 'message:', e.message);
      clearTimeout(safetyTimeout);
      finish();
    };

    // Android Chrome: pequeno delay antes de speak() ap√≥s cancel() anterior
    // Para evitar race condition
    setTimeout(() => {
      if (!this.stopFlag) {
        this.synth.speak(u);
        this.utterance = u;
      } else {
        clearTimeout(safetyTimeout);
        finish();
      }
    }, 50);
  });
},


//   speak(text) {
//     return new Promise((resolve) => {
//       if (this.stopFlag) return resolve();

      
//         const rate = parseFloat(document.getElementById('tts-speed')?.value) || 1.0;
//       const normalized = this.applySpeechDictionary(text);

//       this.utterance = new SpeechSynthesisUtterance(text);
//       this.utterance.rate = rate;

//       this.utterance.onend = () => resolve();
//       this.utterance.onerror = () => resolve();

//       this.synth.speak(this.utterance);
//     });
//   },

  // ===== controles =====
  async play() {
    console.log('[TTS] play() chamado. Playlist length:', this.playlist.length);
    if (!this.playlist.length) {
      console.warn('[TTS] Playlist vazia, abortando play()');
      return;
    }

    // Garante que vozes est√£o prontas antes de come√ßar (Android)
    console.log('[TTS] Inicializando vozes...');
    await this.initVoices();
    console.log('[TTS] Vozes prontas, iniciando playFromHere()');
    this.playFromHere();
  },

  pauseStop() {
    console.log('[TTS] pauseStop() chamado');
    this.stopFlag = true;

    // Libera Wake Lock
    this.releaseWakeLock();

    // Android Chrome: cancel() pode falhar silenciosamente
    // Tenta m√∫ltiplas vezes com delay
    try {
      this.synth.cancel();
      console.log('[TTS] synth.cancel() executado');
    } catch (e) {
      console.warn('[TTS] TTS cancel error:', e);
    }

    // Double-tap para garantir (Android workaround)
    setTimeout(() => {
      try {
        if (this.synth.speaking) {
          this.synth.cancel();
          console.log('[TTS] synth.cancel() executado (2¬™ tentativa)');
        }
      } catch (e) {}
    }, 100);

    this.isPlaying = false;
    this.updateControls();
    console.log('[TTS] pauseStop() conclu√≠do');
  },

  toggle() {
    console.log('[TTS] toggle() chamado. isPlaying:', this.isPlaying);
    if (this.isPlaying) this.pauseStop();
    else this.play();
  },

  next() {
    console.log('[TTS] next() chamado. Cap√≠tulo atual:', this.currentChapter);
    this.pauseStop();
    this.currentChapter = Math.min(this.currentChapter + 1, this.playlist.length - 1);
    this.currentToken = 0;
    console.log('[TTS] Mudou para cap√≠tulo:', this.currentChapter);
    this.updateDisplay();
    this.play();
  },

  prev() {
    console.log('[TTS] prev() chamado. Cap√≠tulo atual:', this.currentChapter);
    this.pauseStop();
    this.currentChapter = Math.max(this.currentChapter - 1, 0);
    this.currentToken = 0;
    console.log('[TTS] Mudou para cap√≠tulo:', this.currentChapter);
    this.updateDisplay();
    this.play();
  },

updateDisplay() {
  const chap = this.playlist[this.currentChapter];
  if (!chap) {
    console.warn('[TTS] updateDisplay: cap√≠tulo n√£o encontrado, index:', this.currentChapter);
    return;
  }

  console.log('[TTS] updateDisplay:', chap.title);
  document.getElementById('tts-chapter').innerText = chap.title;

  // highlight + scroll
  if (chap.id) {
    this.highlightChapterById(chap.id);
    this.scrollToChapterById(chap.id);
  }
},


//   updateDisplay() {
//     const chap = this.playlist[this.currentChapter];
//     if (!chap) return;
//     document.getElementById('tts-chapter').innerText = chap.title;
//   },

  updateControls(ended = false) {
    const btn = document.getElementById('tts-play-btn');
    const status = document.getElementById('tts-status');
    btn.innerText = this.isPlaying ? '‚è∏' : '‚ñ∂';
    status.innerText = ended ? 'Fim' : (this.isPlaying ? 'Reproduzindo...' : 'Pausado');
    console.log('[TTS] updateControls: isPlaying:', this.isPlaying, 'ended:', ended);
  },

  setSpeed() {
    console.log('[TTS] setSpeed() chamado');
    // se est√° tocando, reinicia token atual com nova velocidade
    if (this.isPlaying) {
      this.pauseStop();
      this.play();
    }
  },

  togglePanel: () => {
    console.log('[TTS] togglePanel() chamado (mas media-bar est√° sempre vis√≠vel agora)');
  }
};

//         const TTS = {
//             synth: window.speechSynthesis,
//             playlist: [], // { id, title, text }
//             currentIndex: 0,
//             isPlaying: false,
//             utterance: null,

//             // Varre o DOM para criar cap√≠tulos baseados em H1/H2
//             buildPlaylist: () => {
//                 TTS.playlist = [];
//                 const root = document.getElementById('content');
//                 const elements = Array.from(root.children);
                
//                 let currentChapter = { id: 'intro', title: 'Introdu√ß√£o', text: '' };
                
//                 elements.forEach(el => {
//                     // Se for Heading, fecha o cap√≠tulo anterior e come√ßa novo
//                     if (['H1', 'H2'].includes(el.tagName)) {
//                         if (currentChapter.text.trim().length > 0) {
//                             TTS.playlist.push(currentChapter);
//                         }
//                         currentChapter = { 
//                             id: el.id, 
//                             title: el.innerText, 
//                             text: '' // Inicia vazio
//                         };
//                     } else if (el.tagName === 'TABLE') {
//                         currentChapter.text += ' [[TABLE]] ';
//                     } else {
//                         // Acumula texto (ignora scripts, styles, e mascara c√≥digo)
//                         if(el.tagName === 'PRE') {
//                             currentChapter.text += " . Trecho de c√≥digo. . ";
//                         } else if (!['SCRIPT', 'STYLE', 'SVG'].includes(el.tagName)) {
//                             currentChapter.text += el.innerText + ' ';
//                         }
//                     }
//                 });
//                 // Adiciona o √∫ltimo
//                 if (currentChapter.text.trim().length > 0) TTS.playlist.push(currentChapter);
                
//                 TTS.currentIndex = 0;
//                 TTS.updateDisplay(0);
//             },

//             playChapter: async (index) => {
//   TTS.synth.cancel();
//   if (index < 0 || index >= TTS.playlist.length) return;

//   TTS.currentIndex = index;
//   const track = TTS.playlist[index];

//   // Se o cap√≠tulo tem tabela, faz gate por voz
//   if (Config.settings.askOnTable) {
//     const hasTable = track.text.includes('[[TABLE]]');
//     if (hasTable) {
//       const ans = await Voice.askYesNo('Encontrei uma tabela. Quer que eu leia a tabela? Diga sim ou n√£o.');
//       if (ans === true) {
//         // pega as tabelas do DOM na se√ß√£o inteira (simples)
//         const tables = Array.from(document.querySelectorAll('#content table'));
//         const first = tables[0];
//         const tableSpeech = first ? tableToSpeech(first) : 'N√£o encontrei a tabela para ler.';
//         track.text = track.text.replace('[[TABLE]]', tableSpeech);
//       } else {
//         // pula leitura de tabela
//         track.text = track.text.replace('[[TABLE]]', 'Tabela ignorada.');
//       }
//     }
//   }

//   TTS.utterance = new SpeechSynthesisUtterance(track.text);
//   TTS.utterance.rate = parseFloat(document.getElementById('tts-speed').value) || 1.0;
//   TTS.utterance.onend = () => TTS.next();
//   TTS.utterance.onerror = () => { TTS.synth.cancel(); TTS.isPlaying = false; TTS.updateControls(); };

//   TTS.synth.speak(TTS.utterance);
//   TTS.isPlaying = true;

//   TTS.updateDisplay(index);
//   TTS.updateControls();
//   TTS.updateMediaSession(track);
// },

//             // playChapter: (index) => {
//             //     TTS.synth.cancel(); // Stop hard
//             //     if (index < 0 || index >= TTS.playlist.length) return;

//             //     TTS.currentIndex = index;
//             //     const track = TTS.playlist[index];

//             //     TTS.utterance = new SpeechSynthesisUtterance(track.text);
//             //     TTS.utterance.rate = parseFloat(document.getElementById('tts-speed').value) || 1.0;
                
//             //     // Eventos
//             //     TTS.utterance.onend = () => TTS.next(); // Auto-play next
//             //     TTS.utterance.onerror = () => TTS.stop();

//             //     TTS.synth.speak(TTS.utterance);
//             //     TTS.isPlaying = true;
                
//             //     TTS.updateDisplay(index);
//             //     TTS.updateControls();
//             //     TTS.updateMediaSession(track);
//             // },

//             toggle: () => {
//                 if (TTS.isPlaying) {
//                     TTS.synth.cancel(); // Pause "real" em mobile √© bugado, melhor parar.
//                     TTS.isPlaying = false;
//                     TTS.updateControls();
//                 } else {
//                     TTS.playChapter(TTS.currentIndex);
//                 }
//             },

//             next: () => TTS.playChapter(TTS.currentIndex + 1),
//             prev: () => TTS.playChapter(TTS.currentIndex - 1),
//             setSpeed: (v) => { if(TTS.isPlaying) TTS.playChapter(TTS.currentIndex); }, // Reinicia pra aplicar speed

//             updateDisplay: (index) => {
//                 if(!TTS.playlist[index]) return;
//                 document.getElementById('tts-chapter').innerText = TTS.playlist[index].title;
//             },

//             updateControls: () => {
//                 const btn = document.getElementById('tts-play-btn');
//                 const status = document.getElementById('tts-status');
//                 btn.innerText = TTS.isPlaying ? '‚è∏' : '‚ñ∂';
//                 status.innerText = TTS.isPlaying ? 'Reproduzindo...' : 'Pausado';
//             },

//             updateMediaSession: (track) => {
//                 if ('mediaSession' in navigator) {
//                     navigator.mediaSession.metadata = new MediaMetadata({
//                         title: track.title,
//                         artist: document.getElementById('doc-title').innerText,
//                         album: 'MD Reader'
//                     });
//                     navigator.mediaSession.setActionHandler('play', TTS.toggle);
//                     navigator.mediaSession.setActionHandler('pause', TTS.toggle);
//                     navigator.mediaSession.setActionHandler('previoustrack', TTS.prev);
//                     navigator.mediaSession.setActionHandler('nexttrack', TTS.next);
//                 }
//             },
            
//             togglePanel: () => document.getElementById('media-bar').classList.toggle('visible')
//         };

        // --- 5. VOZ (Reconhecimento e S√≠ntese) ---
        const Voice = {
  enabled: true,
  lang: 'pt-BR',
  timeoutMs: 6000,

  getRecognition() {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR) return null;
    const rec = new SR();
    rec.lang = this.lang;
    rec.interimResults = false;
    rec.maxAlternatives = 1;
    rec.continuous = false;
    return rec;
  },

  normalize(s) {
    return (s || '')
      .toLowerCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
      .trim();
  },

  async speakOnce(text, rate = 1.0) {
    // Aguarda vozes carregarem (Android Chrome precisa)
    await TTS.initVoices();

    return new Promise((resolve) => {
      const u = new SpeechSynthesisUtterance(text);
      u.rate = rate;

      let ended = false;
      const finish = () => {
        if (ended) return;
        ended = true;
        resolve();
      };

      // Timeout de seguran√ßa
      const estimatedDuration = (text.length / rate) * 60 + 2000;
      const safetyTimeout = setTimeout(finish, estimatedDuration);

      u.onend = () => {
        clearTimeout(safetyTimeout);
        finish();
      };

      u.onerror = (e) => {
        console.warn('Voice TTS error:', e);
        clearTimeout(safetyTimeout);
        finish();
      };

      // Delay de 50ms ap√≥s qualquer cancel anterior (Android workaround)
      setTimeout(() => {
        speechSynthesis.speak(u);
      }, 50);
    });
  },

  async askYesNo(promptText) {
    const rec = this.getRecognition();
    if (!this.enabled || !rec) return null;

    console.log('[Voice] askYesNo iniciado:', promptText);

    // evita capturar o pr√≥prio TTS (Android: tenta 2x)
    try {
      speechSynthesis.cancel();
      await new Promise(r => setTimeout(r, 100));
      if (speechSynthesis.speaking) {
        speechSynthesis.cancel();
      }
    } catch (e) {
      console.warn('Cancel error in askYesNo:', e);
    }

    const rate = parseFloat(document.getElementById('tts-speed')?.value) || 1.0;
    await this.speakOnce(promptText, rate);

    // Aguarda um pouco mais antes de iniciar o reconhecimento
    await new Promise(r => setTimeout(r, 500));

    // Mostra indicador visual de microfone
    const micIndicator = document.getElementById('mic-indicator');
    if (micIndicator) {
      micIndicator.classList.add('active');
      console.log('[Voice] Indicador de microfone ativado');
    }

    return new Promise((resolve) => {
      let done = false;
      const finish = (val) => {
        if (done) return;
        done = true;

        // Remove indicador visual
        if (micIndicator) {
          micIndicator.classList.remove('active');
          console.log('[Voice] Indicador de microfone desativado');
        }

        try { rec.stop(); } catch {}
        console.log('[Voice] askYesNo finalizado com resposta:', val);
        resolve(val);
      };

      // Timeout maior para dar tempo do usu√°rio falar
      const timer = setTimeout(() => {
        console.log('[Voice] Timeout - usu√°rio n√£o respondeu');
        finish(null);
      }, 8000); // 8 segundos

      rec.onresult = (e) => {
        clearTimeout(timer);
        const said = this.normalize(e.results?.[0]?.[0]?.transcript);
        console.log('[Voice] Reconhecido:', said);

        const yes = ['sim','claro','pode','ok','ler','leia','manda','vai','positivo'];
        const no  = ['nao','n√£o','negativo','pular','pula','passa','proximo','pr√≥ximo','skip'];

        if (yes.some(w => said.includes(w))) return finish(true);
        if (no.some(w => said.includes(w))) return finish(false);
        return finish(null);
      };

      rec.onerror = (e) => {
        console.warn('Speech Recognition error:', e.error);
        clearTimeout(timer);
        finish(null);
      };

      // Android Chrome: √†s vezes onend n√£o dispara
      rec.onend = () => {
        if (!done) {
          console.log('[Voice] Recognition ended without result');
        }
      };

      try {
        rec.start();
        console.log('[Voice] Recognition iniciado');
      } catch (e) {
        console.warn('Failed to start recognition:', e);
        clearTimeout(timer);
        finish(null);
      }
    });
  }
};

// const Voice = {
//   enabled: true, // vai espelhar Config.settings.handsFree
//   lang: 'pt-BR',
//   timeoutMs: 6000,

//   // Chrome: webkitSpeechRecognition
//   getRecognition() {
//     const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
//     if (!SR) return null;
//     const rec = new SR();
//     rec.lang = this.lang;
//     rec.interimResults = false;
//     rec.maxAlternatives = 1;
//     rec.continuous = false;
//     return rec;
//   },

//   normalize(s) {
//     return (s || '')
//       .toLowerCase()
//       .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // remove acentos
//       .trim();
//   },

//   // fala e resolve quando terminar
//   speak(text, rate = 1.0) {
//     return new Promise((resolve) => {
//       const u = new SpeechSynthesisUtterance(text);
//       u.rate = rate;
//       u.onend = () => resolve();
//       u.onerror = () => resolve();
//       window.speechSynthesis.speak(u);
//     });
//   },

//   // Pergunta sim/n√£o por voz. Retorna true (sim), false (n√£o), null (timeout/erro)
//   async askYesNo(promptText) {
//     const rec = this.getRecognition();
//     if (!this.enabled || !rec) return null;

//     // 1) garante que n√£o vai capturar o pr√≥prio TTS
//     window.speechSynthesis.cancel();

//     // 2) fala a pergunta (sem mic aberto)
//     await this.speak(promptText, parseFloat(document.getElementById('tts-speed')?.value) || 1.0);

//     // 3) d√° uma micro-pausa (em alguns Android ajuda)
//     await new Promise(r => setTimeout(r, 250));

//     return new Promise((resolve) => {
//       let done = false;

//       const finish = (val) => {
//         if (done) return;
//         done = true;
//         try { rec.stop(); } catch {}
//         resolve(val);
//       };

//       const timer = setTimeout(() => finish(null), this.timeoutMs);

//       rec.onresult = (e) => {
//         clearTimeout(timer);
//         const said = this.normalize(e.results?.[0]?.[0]?.transcript);
//         if (!said) return finish(null);

//         // Vocabul√°rio ‚Äúpra vida real‚Äù
//         const yes = ['sim','s','claro','pode','ok','ler','leia','manda','vai','positivo'];
//         const no  = ['nao','n√£o','n','negativo','pular','pula','passa','proximo','pr√≥ximo','skip'];

//         if (yes.some(w => said.includes(w))) return finish(true);
//         if (no.some(w => said.includes(w))) return finish(false);

//         // se falou algo estranho, considera null (pode cair no fallback)
//         return finish(null);
//       };

//       rec.onerror = () => {
//         clearTimeout(timer);
//         finish(null);
//       };

//       rec.onend = () => {
//         // se encerrou sem resultado, timeout/falha
//         // (n√£o chama finish aqui pra n√£o duplar; timer cuida)
//       };

//       try {
//         rec.start();
//       } catch {
//         clearTimeout(timer);
//         finish(null);
//       }
//     });
//   }
// };



        // --- 5. L√ìGICA UI & ARQUIVOS ---
        const Library = {
            importFile: async () => {
                const input = document.createElement('input'); 
                input.type = 'file';
                input.accept = '.md,.markdown,.txt,text/markdown,text/plain';
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if(!file) return;
                    const content = await file.text();
                    const fileData = { 
                        id: (crypto.randomUUID ? crypto.randomUUID() : Date.now().toString()), 
                        name: file.name, 
                        content, 
                        date: new Date().toISOString() 
                    };
                    
                    try {
                        await DB.saveFile(fileData); // Agora espera oncomplete real
                        await Library.loadList();
                        Library.open(fileData.id);
                    } catch(err) { alert('Erro ao salvar no DB: ' + err); }
                };
                input.click();
            },
            loadList: async () => {
                const files = await DB.getAll();
                const list = document.getElementById('file-list');
                list.innerHTML = '';
                files.sort((a,b) => new Date(b.date) - new Date(a.date)).forEach(f => {
                    const div = document.createElement('div');
                    div.className = 'lib-item';
                    div.innerHTML = `<div><b>${f.name}</b><br><small>${new Date(f.date).toLocaleDateString()}</small></div>`;
                    div.onclick = () => Library.open(f.id);
                    list.appendChild(div);
                });
            },
            open: async (id) => {
                const file = await DB.get(id);
                document.getElementById('doc-title').innerText = file.name;
                Renderer.render(file.content);
                if(window.innerWidth < 768) UI.toggleSidebar();
            }
        };

        const UI = {
            toggleSidebar: () => document.getElementById('app-container').classList.toggle('show-sidebar'),
            toggleSettings: () => {
                const s = document.getElementById('panel-settings');
                const l = document.getElementById('panel-library');
                s.style.display = s.style.display === 'none' ? 'block' : 'none';
                l.style.display = s.style.display === 'none' ? 'block' : 'none';
            },
            toggleTOC: () => document.getElementById('app-container').classList.toggle('show-toc'),
            toggleDebug: () => {
                const debugEl = document.getElementById('debug-console');
                debugEl.classList.toggle('visible');
                console.log('Debug console toggled');
            }
        };

        function tableToSpeech(tableEl) {
  const rows = Array.from(tableEl.querySelectorAll('tr'))
    .map(tr => Array.from(tr.querySelectorAll('th,td')).map(td => td.innerText.trim()));

  if (!rows.length) return 'Tabela vazia.';
  const header = rows[0];
  const body = rows.slice(1);

  let out = `Tabela com ${body.length} linhas e ${header.length} colunas. `;
  out += `Cabe√ßalhos: ${header.join(', ')}. `;

  body.slice(0, 20).forEach((r, i) => { // limita pra n√£o virar infinito
    out += `Linha ${i+1}: ${r.join('; ')}. `;
  });

  if (body.length > 20) out += `Restante omitido. `;
  return out;
}

function setHandsFree(v) {
  Config.settings.handsFree = v;
  localStorage.setItem('md_settings', JSON.stringify(Config.settings));
  Voice.enabled = v;
}

        // Boot
        window.onload = () => {
            // Inicia debug console PRIMEIRO
            DebugConsole.init();
            console.log('PKMLite v1.6.1 iniciando...');

            Config.apply();
            console.log('Configura√ß√µes aplicadas');

            DB.init().then(() => {
                console.log('Database inicializado');
                Library.loadList();
            });

            // Pr√©-carrega vozes (Android Chrome)
            console.log('Pr√©-carregando vozes TTS...');
            TTS.initVoices().then(() => {
                console.log('Vozes TTS carregadas');
            });

            // Detec√ß√£o de scroll manual
            let scrollTimer = null;
            window.addEventListener('scroll', () => {
            TTS.userIsScrolling = true;
            clearTimeout(scrollTimer);
            scrollTimer = setTimeout(() => { TTS.userIsScrolling = false; }, 800);
            }, { passive: true });

            // Android Chrome: pausa TTS quando app vai para background
            let wasPlayingBeforeHidden = false;
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    // Salva estado antes de ocultar
                    wasPlayingBeforeHidden = TTS.isPlaying;
                    if (wasPlayingBeforeHidden) {
                        console.log('App em background - pausando TTS');
                        TTS.pauseStop();
                    }
                } else {
                    // Quando volta, re-adquire Wake Lock se estava tocando
                    if (wasPlayingBeforeHidden && 'wakeLock' in navigator) {
                        TTS.acquireWakeLock();
                    }
                }
            });

            if ('serviceWorker' in navigator) navigator.serviceWorker.register('./sw.js');
        };

    </script>
</body>
</html>